package fr.insee.eno.core.model.navigation;

import fr.insee.ddi.lifecycle33.datacollection.ComputationItemType;
import fr.insee.eno.core.annotations.Contexts.Context;
import fr.insee.eno.core.annotations.DDI;
import fr.insee.eno.core.annotations.Lunatic;
import fr.insee.eno.core.annotations.Pogues;
import fr.insee.eno.core.exceptions.business.IllegalDDIElementException;
import fr.insee.eno.core.exceptions.technical.MappingException;
import fr.insee.eno.core.model.EnoIdentifiableObject;
import fr.insee.eno.core.model.EnoObjectWithExpression;
import fr.insee.eno.core.model.calculated.CalculatedExpression;
import fr.insee.eno.core.model.label.DynamicLabel;
import fr.insee.eno.core.parameter.Format;
import fr.insee.eno.core.utils.DDIUtils;
import fr.insee.lunatic.model.flat.ControlContextType;
import fr.insee.lunatic.model.flat.ControlCriticalityEnum;
import fr.insee.lunatic.model.flat.ControlType;
import fr.insee.lunatic.model.flat.ControlTypeEnum;
import fr.insee.pogues.model.ControlCriticityEnum;
import lombok.Getter;
import lombok.Setter;

import java.util.Map;

/** Consistency check. */
@Getter
@Setter
@Context(format = Format.POGUES, type = fr.insee.pogues.model.ControlType.class)
@Context(format = Format.DDI, type = ComputationItemType.class)
@Context(format = Format.LUNATIC, type = ControlType.class)
public class Control extends EnoIdentifiableObject implements EnoObjectWithExpression {

    public enum Criticality {INFO, WARN, ERROR}

    public enum TypeOfControl { CONSISTENCY, FORMAT }

    public enum Context {SIMPLE, ROW}

    public static Criticality convertDDICriticality(String ddiTypeOfComputationItem) {
        return switch (ddiTypeOfComputationItem) {
            case "informational", "line-informational" -> Criticality.INFO;
            case "warning", "line-warning" -> Criticality.WARN;
            case "stumblingblock", "line-stumblingblock", "roundabout-locked" -> Criticality.ERROR;
            default -> throw new MappingException(String.format(
                    "Unknown DDI criticality '%s'", ddiTypeOfComputationItem));
        };
    }

    public static ControlCriticalityEnum convertCriticalityToLunatic(Criticality criticality) {
        return switch (criticality) {
            case INFO -> ControlCriticalityEnum.INFO;
            case WARN -> ControlCriticalityEnum.WARN;
            case ERROR ->  ControlCriticalityEnum.ERROR;
        };
    }

    public static ControlTypeEnum convertTypeOfControlToLunatic(TypeOfControl typeOfControl) {
        return switch (typeOfControl) {
            case FORMAT -> ControlTypeEnum.FORMAT;
            case CONSISTENCY -> ControlTypeEnum.CONSISTENCY;
        };
    }

    /** With the current modeling, controls that are described in the DDI are always of type 'consistency'.
     * In DDI, computation item only describe controls that are defined by the questionnaire's designer.
     * ("Format" controls are generated by Eno using questions' metadata.) */
    public static TypeOfControl mapTypeFromDDIandPogues() {
        return TypeOfControl.CONSISTENCY;
    }

    public static ControlContextType convertContextToLunatic(Context context) {
        return switch (context) {
            // Note: "simple" and null are equivalent in Lunatic
            case null -> ControlContextType.SIMPLE;
            case SIMPLE -> ControlContextType.SIMPLE;
            case ROW -> ControlContextType.ROW;
        };
    }

    /** In DDI, there is only one concept for the type of controls.
     * The computation item type has a 'type of computation item' property.
     * If this property stats with 'line', it is a dynamic table line control that can be marked as a row control. */
    public static Context mapContextFromDDI(ComputationItemType computationItemType) {
        String ddiTypeOfComputationItem = computationItemType.getTypeOfComputationItem().getStringValue();
        //
        if (ddiTypeOfComputationItem == null)
            throw new IllegalDDIElementException(
                    "DDI type of control is not defined in " + DDIUtils.ddiToString(computationItemType) + ".");
        //
        if (ddiTypeOfComputationItem.startsWith("line"))
            return Context.ROW;
        return Context.SIMPLE;
    }

    private static final Map<ControlCriticityEnum, Criticality> poguesCriticalities = Map.of(
            ControlCriticityEnum.INFO, Criticality.INFO,
            ControlCriticityEnum.WARN, Criticality.WARN,
            ControlCriticityEnum.ERROR,Criticality.ERROR);

    public static Criticality convertPoguesCriticality(ControlCriticityEnum poguesCriticality){
        return poguesCriticalities.get(poguesCriticality);
    }

    /** Control criticality. */
    @Pogues("T(fr.insee.eno.core.model.navigation.Control).convertPoguesCriticality(" +
            "getCriticity())")
    @DDI("T(fr.insee.eno.core.model.navigation.Control).convertDDICriticality(" +
            "getTypeOfComputationItem().getStringValue())")
    @Lunatic("setCriticality(T(fr.insee.eno.core.model.navigation.Control).convertCriticalityToLunatic(#param))")
    private Criticality criticality;

    /** Here, typeOfControl always equals CONSISTENCY. Indeed, CONSISTENCY means entered by the designer,
     *  whereas FORMAT means generated by ENO. */
    @Pogues("T(fr.insee.eno.core.model.navigation.Control).mapTypeFromDDIandPogues()")
    @DDI("T(fr.insee.eno.core.model.navigation.Control).mapTypeFromDDIandPogues()")
    @Lunatic("setTypeOfControl(T(fr.insee.eno.core.model.navigation.Control).convertTypeOfControlToLunatic(#param))")
    private TypeOfControl typeOfControl;

    /** The context of a control is "simple" by default.
     * In DDI, "row" controls are marked with both the mapping annotation and a processing step.
     * @see fr.insee.eno.core.processing.in.steps.ddi.DDIMarkRowControls */
    @DDI("T(fr.insee.eno.core.model.navigation.Control).mapContextFromDDI(#this)")
    @Lunatic("setType(T(fr.insee.eno.core.model.navigation.Control).convertContextToLunatic(#param))")
    private Context context = Context.SIMPLE;

    /** Label typed in Pogues, unused in Lunatic. */
    @Pogues("getDescription()")
    @DDI("getDescription()?.getContentArray(0)?.getStringValue()") // NOTE: getConstructNameArray(0).getStringArray(0).getStringValue() has the same information
    private String label;

    /** Expression that determines if the control is triggered or not. */
    @Pogues("getExpression()")
    @DDI("getCommandCode().getCommandArray(0)")
    @Lunatic("setControl(#param)")
    private CalculatedExpression expression;

    /** Message displayed if the control is triggered. */
    @Pogues("getFailMessage()")
    @DDI("!#this.getInterviewerInstructionReferenceList().isEmpty() ? " +
            "#index.get(#this.getInterviewerInstructionReferenceArray(0).getIDArray(0).getStringValue())" +
            ".getInstructionTextArray(0) : " +
            "null")
    @Lunatic("setErrorMessage(#param)")
    private DynamicLabel message;

}
