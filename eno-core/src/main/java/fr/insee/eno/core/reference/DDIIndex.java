package fr.insee.eno.core.reference;

import fr.insee.eno.core.exceptions.business.DuplicateIdException;
import fr.insee.eno.core.exceptions.technical.IndexingException;
import fr.insee.eno.core.mappers.Mapper;
import instance33.DDIInstanceDocument;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanWrapper;
import org.springframework.beans.BeanWrapperImpl;
import org.springframework.core.convert.TypeDescriptor;
import reusable33.AbstractIdentifiableType;

import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.util.*;

/**
 * Class designed to store all DDI identifiable objects within a DDI object in a flat map.
 */
@Slf4j
public class DDIIndex {

    /** Index of DDI identifiable objects.
     * Key: a DDI object identifier
     * Value: the DDI object with corresponding identifier. */
    private Map<String, AbstractIdentifiableType> index;

    /** Map containing nesting relationships between objects in index.
     * Key: a DDI object identifier
     * Value: the identifier of its parent object */
    private Map<String, String> parentsMap;

    private void setup() {
        index = new HashMap<>();
        parentsMap = new HashMap<>();
    }

    /**
     * Store all DDI identifiable objects that are in the given DDI document in the index.
     * @param ddiInstanceDocument A DDIInstanceDocument.
     */
    public void indexDDI(DDIInstanceDocument ddiInstanceDocument) {
        log.info("Indexing objects of DDI document");
        indexDDIObject(ddiInstanceDocument.getDDIInstance());
        log.info("Finished indexing of DDI document");
    }

    /**
     * Store all DDI identifiable objects that are in the given DDI object in the index.
     * @param ddiObject A DDI identifiable object.
     */
    public void indexDDIObject(AbstractIdentifiableType ddiObject) {
        setup();
        recursiveIndexing(ddiObject);
    }

    /**
     * In DDI, the most generic object is the AbstractIdentifiableType
     * (i.e. each DDI object that has an id is an AbstractIdentifiableType).
     * This method recursively path through all AbstractIdentifiableType objects within the given object.
     * @param ddiObject A AbstractIdentifiableType object.
     */
    private void recursiveIndexing(AbstractIdentifiableType ddiObject) {

        // Get the DDI object id
        String ddiObjectId = ddiObject.getIDArray(0).getStringValue();

        // Put the object in the map under the id (there should never be duplicate ids in DDI documents)
        index.merge(ddiObjectId, ddiObject, (oldDDIObject, newDDIObject) -> {
            throw new DuplicateIdException(String.format("Duplicate ID \"%s\" found in given DDI.", ddiObjectId));
        });

        // Use Spring BeanWrapper to iterate on object property descriptors
        BeanWrapper beanWrapper = new BeanWrapperImpl(ddiObject);
        for (Iterator<PropertyDescriptor> iterator = Mapper.propertyDescriptorIterator(beanWrapper); iterator.hasNext();) {
            PropertyDescriptor propertyDescriptor = iterator.next();

            // In DDI classes, everything is in a list
            if (List.class.isAssignableFrom(propertyDescriptor.getPropertyType())) {

                // Use Spring TypeDescriptor to determine the content type of the list
                TypeDescriptor typeDescriptor = beanWrapper.getPropertyTypeDescriptor(propertyDescriptor.getName());
                assert typeDescriptor != null;
                Class<?> listContentType = typeDescriptor.getResolvableType().getGeneric(0).getRawClass();

                // In some DDI objects, there are some methods (generated by xmlbeans) that does not interest us
                assert listContentType != null || propertyDescriptor.getName().equals("listValue")
                        || propertyDescriptor.getName().equals("limitArrayIndex");

                // Check that the list content applies for AbstractIdentifiableType
                if (listContentType != null && AbstractIdentifiableType.class.isAssignableFrom(listContentType)) {

                    // Now that we have what we want, index list content
                    indexListContent(ddiObject, ddiObjectId, propertyDescriptor);
                }
            }
        }

    }

    private void indexListContent(AbstractIdentifiableType ddiObject, String ddiObjectId, PropertyDescriptor propertyDescriptor) {
        try {
            // Iteration on each object in the list.
            @SuppressWarnings("unchecked") // https://stackoverflow.com/a/4388173/13425151
            Collection<AbstractIdentifiableType> ddiCollection = (Collection<AbstractIdentifiableType>) propertyDescriptor.getReadMethod().invoke(ddiObject);
            for (AbstractIdentifiableType ddiObject2 : ddiCollection) {
                // Keep track of link between nested objects
                parentsMap.put(ddiObject2.getIDArray(0).getStringValue(), ddiObjectId);
                // Recursive call of the function
                recursiveIndexing(ddiObject2);
            }
        } catch (IllegalAccessException | InvocationTargetException e) {
            throw new IndexingException(String.format(
                    "Error when calling read method from property descriptor '%s' in class %s.",
                    propertyDescriptor.getName(), ddiObject.getClass()),
                    e);
        }
    }

    /** Return the DDI object corresponding to the given identifier,
     * null if the identifier is not in the index. */
    public AbstractIdentifiableType get(String ddiObjectId) {
        return index.get(ddiObjectId);
    }

    /** Return true if the index contains the given identifier. */
    public boolean containsId(String ddiObjectId) {
        return index.containsKey(ddiObjectId);
    }

    /** Return parent object of DDI object with given identifier. */
    public AbstractIdentifiableType getParent(String ddiObjectId) {
        return index.get(parentsMap.get(ddiObjectId));
    }

    @Override
    public String toString() {
        return "DDIIndex["+index.size()+" elements]";
    }
}
