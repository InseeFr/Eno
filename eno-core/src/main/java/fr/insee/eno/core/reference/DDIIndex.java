package fr.insee.eno.core.reference;

import fr.insee.eno.core.mappers.Mapper;
import fr.insee.eno.core.model.EnoObject;
import instance33.DDIInstanceDocument;
import instance33.DDIInstanceType;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanWrapper;
import org.springframework.beans.BeanWrapperImpl;
import org.springframework.core.convert.TypeDescriptor;
import reusable33.AbstractIdentifiableType;

import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.util.*;

/**
 * Flat map designed to store all objects of a DDI document.
 * Keys: string identifiers of DDI objects
 * Values: the corresponding objects
 */
@Slf4j
public class DDIIndex { //TODO: AbstractIdentifiableType i.o. Object

    private Map<String, Object> index;
    /**
     * Key: a DDI object identifier
     * Value: the identifier of its parent object */
    private Map<String, String> parentsMap;

    private void setup() {
        index = new HashMap<>();
        parentsMap = new HashMap<>();
    }

    /**
     * Store all objects in the DDI document given in the map.
     * @param ddiInstanceDocument A DDIInstanceDocument
     */
    public void indexDDI(DDIInstanceDocument ddiInstanceDocument) {
        log.info("Indexing objects of DDI document");
        indexDDIObject(ddiInstanceDocument.getDDIInstance());
        log.info("Finished indexing of DDI document");
    }

    public void indexDDIObject(AbstractIdentifiableType ddiObject) {
        setup();
        recursiveIndexing(ddiObject);
    }

    /**
     * In DDI, the most generic object is the AbstractIdentifiableType
     * (i.e. each DDI object that has an id is an AbstractIdentifiableType).
     * This method recursively path through all AbstractIdentifiableType objects within the given object.
     * @param ddiObject A AbstractIdentifiableType object.
     */
    private void recursiveIndexing(AbstractIdentifiableType ddiObject) {

        // Get the DDI object id
        String ddiObjectId = ddiObject.getIDArray(0).getStringValue();

        // Put the object in the map under the id (there should never be duplicate ids in DDI documents)
        index.merge(ddiObjectId, ddiObject, (oldDDIObject, newDDIObject) -> {
            throw new RuntimeException(String.format("Duplicate ID \"%s\" found in given DDI.", ddiObjectId));
        });

        // Use Spring BeanWrapper to iterate on object property descriptors
        BeanWrapper beanWrapper = new BeanWrapperImpl(ddiObject);
        for (Iterator<PropertyDescriptor> iterator = Mapper.propertyDescriptorIterator(beanWrapper); iterator.hasNext();) {
            PropertyDescriptor propertyDescriptor = iterator.next();

            // In DDI classes, everything is in a list
            if (List.class.isAssignableFrom(propertyDescriptor.getPropertyType())) {

                // Use Spring TypeDescriptor to determine the content type of the list
                TypeDescriptor typeDescriptor = beanWrapper.getPropertyTypeDescriptor(propertyDescriptor.getName());
                assert typeDescriptor != null;
                Class<?> listContentType = typeDescriptor.getResolvableType().getGeneric(0).getRawClass();

                // In some DDI objects, there is a 'listValue' method (generated by xmlbeans) that does not interest us
                assert listContentType != null || propertyDescriptor.getName().equals("listValue");

                // Check that the list content applies for AbstractIdentifiableType
                if (listContentType != null && AbstractIdentifiableType.class.isAssignableFrom(listContentType)) {
                    try {
                        // Iteration on each object in the list.
                        @SuppressWarnings("unchecked") // https://stackoverflow.com/a/4388173/13425151
                        Collection<AbstractIdentifiableType> ddiCollection = (Collection<AbstractIdentifiableType>) propertyDescriptor.getReadMethod().invoke(ddiObject);
                        for (AbstractIdentifiableType ddiObject2 : ddiCollection) {
                            // Keep track of link between nested objects
                            parentsMap.put(ddiObject2.getIDArray(0).getStringValue(), ddiObjectId);
                            // Recursive call of the function
                            recursiveIndexing(ddiObject2);
                        }
                    } catch (IllegalAccessException | InvocationTargetException e) {
                        throw new RuntimeException(String.format(
                                "Error when calling read method from property descriptor '%s' in class %s.",
                                propertyDescriptor.getName(), ddiObject.getClass()),
                                e);
                    }
                }
            }
        }

    }

    public Object get(String ddiObjectId) {
        return index.get(ddiObjectId);
    }

    public boolean containsId(String ddiObjectId) {
        return index.containsKey(ddiObjectId);
    }

    /** Return parent object of DDI object with given identifier. */
    public Object getParent(String ddiObjectId) { //TODO: AbstractIdentifiableType i.o. Object
        return index.get(parentsMap.get(ddiObjectId));
    }

    @Override
    public String toString() {
        return "DDIIndex["+index.size()+" elements]";
    }
}
